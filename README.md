# Shablone - Шаблонизатор
Веб‑приложение на **Flask** для создания и редактирования **графических шаблонов** (холст + текст + изображения) и их генерации в PNG.

Проект решает задачи:
- хранить шаблоны под конкретные параметры каталога (*бренд*, *подтип изделия*, *тип металла*);
- давать пользователю визуальный редактор на Canvas (перетаскивание, ресайз, оформление);
- генерировать изображения на сервере и выдавать предпросмотр/архив.

Основной сценарий:
1) создать шаблон для набора параметров (*бренд*, *подтип изделия*, *тип металла*);
2) собрать композицию на холсте (фон, текст, картинки, «плейсхолдер изделия»);
3) нажать «Сохранить» — сервер сгенерирует PNG‑предпросмотр;
4) при наличии списка товаров в БД — сгенерировать изображения для всех товаров и скачать **ZIP‑архив**.

## Возможности

- Список шаблонов с фильтрами по бренду / типу / подтипу / металлу.
- Визуальный редактор шаблона на `<canvas>`:
  - изменение размера холста и цвета фона;
  - добавление текста (шрифт, размер, жирность, цвет, координаты);
  - добавление изображений (загрузка на сервер), перемещение мышью, изменение размеров (за «уголки»), опциональная тень;
  - добавление «изделия» (плейсхолдер `product.png`) для последующей пакетной генерации.
- Генерация итогового изображения на сервере через **ImageMagick**:
  - предпросмотр: `GET /api/template/<id>/image/`;
  - пакетная генерация: `GET /api/template/<id>/zip/` (архив PNG по товарам из БД).

## Технологии

- Backend: **Python**, **Flask**
- База: **SQLite** (через **Peewee**)
- Рендер: **ImageMagick CLI** (`magick`), **Pillow** (сброс метаданных у PNG)
- Frontend: HTML/CSS/JS + Canvas

## Структура проекта

- `app.py` — Flask‑приложение, API и генерация изображений
- `models.py` — модели Peewee и создание таблиц в `db.db`
- `templates/` — HTML‑шаблоны (`index.html`, `edit_pattern.html`)
- `static/` — JS и CSS (`index.js`, `edit_pattern.js`, `styles/*`)
- `fonts/` — ttf‑шрифты и маппинг имени → файл (`fonts/font.py`)
- `image/` — статичные картинки (в т.ч. `product.png`, `delete.png`)
- `images/` — (создаётся при запуске) загруженные пользователем изображения
- `products/` — (создаётся при запуске) временно скачанные картинки товаров
- `projects/` — (создаётся при запуске) результаты рендера по шаблонам

## Требования

- Python 3.10+ (рекомендуется)
- Установленный **ImageMagick** и доступная команда `magick` в `PATH`

⚠️ В `app.py` для копирования файлов используется команда `copy` (Windows).  
Если вы запускаете проект на Linux/macOS, замените `copy` на `cp` (или используйте `shutil.copy`) в функции `generate_cmd_by_image()`.

Мини‑патч для Linux/macOS (пример):
```diff
- run_cmd(f'copy "{image_path}" "{tmp_path}"')
+ run_cmd(f'cp "{image_path}" "{tmp_path}"')
```

## Быстрый старт

```bash
# 1) Установить зависимости
python -m venv .venv
# Windows: .venv\Scripts\activate
# Linux/macOS:
source .venv/bin/activate
pip install -r requirements.txt

# 2) Запуск
python app.py
```

Открыть в браузере:  
- Главная (список шаблонов): http://127.0.0.1:5000  
- Редактор шаблона: http://127.0.0.1:5000/template/<template_id>/

При первом запуске приложение:
- создаст папки `images/`, `projects/`, `products/` (если их нет);
- создаст SQLite‑файл `db.db` и таблицы (см. `models.py`).

## Заполнение БД (обязательно для осмысленной работы)

Интерфейс «админки» в проекте не предусмотрен — справочники и товары нужно добавить в `db.db` вручную (через SQLite‑клиент) или скриптом.

Пример заполнения через Python:

```bash
python - <<'PY'
from models import db, Brand, MetalType, ProductType, ProductSubtype, Product

db.connect(reuse_if_open=True)

# справочники
brand, _ = Brand.get_or_create(name="SOKOLOV")
metal, _ = MetalType.get_or_create(name="Silver")
ptype, _ = ProductType.get_or_create(name="Earrings")
psub, _ = ProductSubtype.get_or_create(name="Stud earrings", product_type=ptype)

# товары (url должен отдавать картинку; файл сохраняется как .png)
Product.get_or_create(
    product_subtype=psub,
    brand=brand,
    metal_type=metal,
    url="https://example.com/product_image.png",
)

db.close()
print("OK")
PY
```

> Важно: при генерации архива `/api/template/<id>/zip/` сервер скачивает изображения по `Product.url` и сохраняет их в `products/<product_id>.png`. Убедитесь, что URL реально возвращает изображение (PNG/JPG и т.п.).

## Как пользоваться

1) На главной странице нажмите **«Создать шаблон»**, выберите бренд/металл/подтип и создайте шаблон.  
2) В редакторе:
   - настройте размеры холста и фон;
   - добавьте текст/изображения;
   - **обязательно** добавьте «изделие» (кнопка **Добавить изделие**) — это вставляет плейсхолдер `product.png`;
   - нажмите **Сохранить**.
3) Для предпросмотра на главной странице карточка шаблона использует `/api/template/<id>/image/`.
4) Чтобы скачать ZIP‑архив с генерацией по товарам, нажмите **«Скачать архив»** в редакторе.

## Формат JSON шаблона

Шаблон хранится в поле `Template.json` (SQLite) в виде JSON со структурой:

```json
{
  "id": 1,
  "width": 800,
  "height": 800,
  "color": "#ffffff",
  "entities": [
    {
      "type": "text",
      "text": "SALE",
      "font": "Montserrat",
      "fontSize": 72,
      "fontWeight": "bold",
      "color": "#000000",
      "x": 40,
      "y": 120
    },
    {
      "type": "image",
      "id": 12,
      "url": "api/image/12",
      "x": 0,
      "y": 0,
      "width": 400,
      "height": 400,
      "shadow": false
    },
    {
      "type": "image",
      "id": "product.png",
      "url": "/api/image/product.png",
      "x": 200,
      "y": 300,
      "width": 400,
      "height": 400
    }
  ]
}
```

Примечания:
- `entities[].type`: `text` или `image`.
- Для `text`: `font` должен быть одним из значений, которые поддерживаются в `templates/edit_pattern.html` и `fonts/font.py`.
- Для `image`:
  - `id` — либо числовой ID загруженного изображения (`/api/image/<id>/`), либо строка с именем файла из папки `image/` (например `product.png`).
  - `shadow` — опциональный `true/false`.
- Для пакетной генерации **нужен** объект изображения с `id == "product.png"` (плейсхолдер изделия).

## API

> В репозитории есть `api_doc.md`, но актуальная структура шаблона — как в разделе «Формат JSON шаблона» выше.

### Справочники
- `GET /api/producttype/` — список типов изделий
- `GET /api/productsubtype/?product_type=<id>` — список подтипов (можно фильтровать по типу)
- `GET /api/brand/` — список брендов
- `GET /api/metaltype/` — список типов металла

### Шаблоны
- `POST /api/template/` — создать шаблон  
  Тело (JSON):
  ```json
  { "brand_id": 1, "metal_type_id": 1, "product_subtype_id": 1 }
  ```
  Ответ:
  ```json
  { "template_id": 1 }
  ```

- `GET /api/template/?brand_id=...&product_subtype_id=...&metal_type_id=...` — список шаблонов

- `GET /api/template/<id>/` — получить JSON шаблона

- `PATCH /api/template/<id>/` — сохранить/обновить JSON шаблона  
  Тело: полный объект шаблона (как возвращает редактор).  
  Сервер удаляет из `entities[]` поле `image` (кэш‑объект браузера) и сохраняет JSON в БД, затем генерирует `projects/<id>/result.png`.

- `DELETE /api/template/<id>/` — удалить шаблон

- `GET /api/template/<id>/image/` — PNG‑предпросмотр (генерируется при необходимости)

- `GET /api/template/<id>/zip/` — ZIP‑архив с PNG по всем товарам из БД, подходящим под (brand, metal_type, product_subtype)

### Изображения
- `POST /api/image/` — загрузка изображения (form‑data, ключ `image`)
- `GET /api/image/<int:image_id>/` — получить загруженное изображение
- `GET /api/image/<string:image_name>/` — получить статичную картинку из папки `image/` (например `product.png`)

## Известные ограничения и нюансы

- Рендер сильно завязан на **ImageMagick** (вызовы через shell). Для продакшена стоит ограничить ввод пользователя (например, экранирование текста) и добавить изоляцию/очередь задач.
- В `app.py` приложение запускается с `debug=True` — не используйте так в продакшене.
- В `GET /api/template/<id>/zip/` происходит `shutil.rmtree(project_path)` без проверки существования папки. Если папка `projects/<id>` ещё не создана, вызов может упасть. Обычно папка появляется после первого «Сохранить» (когда сгенерирован предпросмотр).

## Добавление новых шрифтов

1) положите `.ttf` в `fonts/`;
2) добавьте запись в `fonts/font.py` (`FONT_LIST`/`FONT_DATA`);
3) добавьте option в список шрифтов в `templates/edit_pattern.html`.

## Выводы по результатам проекта

- Реализован полный цикл работы с графическими шаблонами: создание → редактирование → предпросмотр → пакетная генерация.
- Выделены сущности предметной области (бренд/металл/тип/подтип/товар/шаблон) и обеспечена связка шаблонов с каталогом.
- Canvas-редактор и серверный рендер позволяют воспроизводимо получать итоговые изображения и масштабировать генерацию на множество товаров (выгрузка ZIP).
- Проект можно развивать в сторону: сценариев/слоёв, шаблонов для разных размеров, версии шаблонов, очередей задач и авторизации.
